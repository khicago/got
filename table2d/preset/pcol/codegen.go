package pcol

import (
	"io"
	"text/template"

	"github.com/khicago/got/table2d/preset/pseal"
	"github.com/khicago/got/util/inlog"
	"github.com/khicago/got/util/strs"
	"github.com/khicago/got/util/typer"
)

var tpl = `// col reader of {{.root_name}}, generated by github.com/khicago/got/table2d/preset/cmd
package {{.pack_name}}

import (
    "github.com/khicago/got/table2d/preset"
    "github.com/khicago/got/table2d/preset/pcol"
)
{{range $cla := .classes}}
type {{$cla.Name}} struct {
    ch *pcol.ColHeader
}

func New{{$cla.Name}}(ch *pcol.ColHeader) *{{$cla.Name}} {
    return &{{$cla.Name}}{ch: ch}
}

func (p *{{$cla.Name}}) PHeader() *pcol.ColHeader {
    return p.ch
}

// ============= Meta block =============
{{range $fname, $finfo := $cla.Methods}}
// MetaOf{{$fname}} returns ColMeta of {{$fname}} 
func (p *{{$cla.Name}}) MetaOf{{$fname}}() *pcol.ColMeta {
    return p.ch.Get({{$finfo.Col}})
}
{{end}}
// ============= Reader block =============
{{range $fname, $finfo := $cla.Methods}}
// {{$fname}} reads the value of {{$fname}} 
func (p *{{$cla.Name}}) {{$fname}}(prop preset.IProp) ({{$finfo.TypeName}}, error) {
    seal := prop.Get({{$finfo.Col}})
    return seal.{{$finfo.SealMethod}}()
}
{{end}}

{{end}}
`

type (
	MethodInfo struct {
		Col        Col
		TypeName   string
		SealMethod string
		Meta       *ColMeta
	}

	ClassInfo struct {
		Name    string
		Methods map[string]MethodInfo
	}
)

func NewClass(className string, header *ColHeader) *ClassInfo {
	cla := &ClassInfo{
		Name:    strs.Conv2Camel(className),
		Methods: make(map[string]MethodInfo),
	}

	typer.MapForEachOrderly(header.Def, func(col Col, meta *ColMeta) {
		if meta.Type == pseal.TyNil {
			return
		}

		if meta.Type == pseal.TyMark {
			return
		}

		if typer.AssertZeroVal(meta.Name) {
			inlog.Warnf("got empty name %#v", meta)
		}

		cla.Methods[strs.Conv2Camel(meta.Name)] = MethodInfo{
			Col:        col,
			TypeName:   meta.Type.TypeName(),
			SealMethod: meta.Type.SealCallName(),
			Meta:       meta,
		}

	})

	return cla
}

func GenerateCode(ch *ColHeader, packName, tableName string, wr io.Writer) error {

	t := template.New("Template")
	t, _ = t.Parse(tpl)

	classes := []*ClassInfo{NewClass(tableName, ch)}
	b := map[string]any{
		"pack_name": strs.Conv2Snake(packName),
		"root_name": strs.Conv2Camel(tableName),
		"classes":   classes,
	}

	return t.Execute(wr, b)
}
